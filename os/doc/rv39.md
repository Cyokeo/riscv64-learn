# RISC-V RV39页表项格式及内容解析

## 页表项基本信息

- **大小**: 64位 (8字节)
- **适用**: RV39地址转换模式
- **物理地址宽度**: 最大56位

## 页表项位域结构

```
 63  62-54 53-28 27-19 18-10  9-8  7  6  5  4  3  2  1  0
┌───┬─────┬─────┬─────┬─────┬────┬─┬──┬──┬──┬──┬──┬──┬──┐
│ N │ PBMT│ RSV │ PPN2│ PPN1│PPN0│D│A │G │U │X │W │R │V │
└───┴─────┴─────┴─────┴─────┴────┴─┴──┴──┴──┴──┴──┴──┴──┘
```

## 各位域详细说明

### 物理页号 (PPN - Physical Page Number)

| 位域 | 名称 | 描述 |
|------|------|------|
| [53:28] | PPN[2] | 物理页号的高26位 |
| [27:19] | PPN[1] | 物理页号的中9位 |
| [18:10] | PPN[0] | 物理页号的低9位 |

**PPN计算公式:**
```
物理页号 = PPN[2] << 18 | PPN[1] << 9 | PPN[0]
物理地址 = (物理页号 << 12) | 页内偏移
```

### 状态和权限位

| 位 | 名称 | 功能描述 |
|----|------|----------|
| [0] | V (Valid) | **有效位**: 1=有效, 0=无效 |
| [1] | R (Read) | **读权限**: 1=可读, 0=不可读 |
| [2] | W (Write) | **写权限**: 1=可写, 0=不可写 |
| [3] | X (eXecute) | **执行权限**: 1=可执行, 0=不可执行 |
| [4] | U (User) | **用户访问**: 1=用户可访问, 0=仅特权模式 |
| [5] | G (Global) | **全局映射**: 1=全局有效, 0=ASID相关 |
| [6] | A (Accessed) | **访问位**: 1=已访问, 0=未访问 |
| [7] | D (Dirty) | **脏位**: 1=已修改, 0=未修改 |

### 扩展位域

| 位域 | 名称 | 描述 |
|------|------|------|
| [9:8] | RSW | **软件保留位**: 供软件使用 |
| [62:54] | PBMT | **页基内存类型**: 内存访问属性 |
| [63] | N | **NAPOT**: 自然对齐的二次幂区域标志 |

## 页表项类型判断

根据RWX位的组合，页表项有不同含义：

| R | W | X | 页表项类型 | 描述 |
|---|---|---|-----------|------|
| 0 | 0 | 0 | **指针页表项** | 指向下一级页表 |
| 0 | 0 | 1 | **叶子页表项** | 仅执行页面 |
| 0 | 1 | 0 | **保留** | 未来使用 |
| 0 | 1 | 1 | **叶子页表项** | 可执行可写页面 |
| 1 | 0 | 0 | **叶子页表项** | 只读页面 |
| 1 | 0 | 1 | **叶子页表项** | 只读可执行页面 |
| 1 | 1 | 0 | **叶子页表项** | 读写页面 |
| 1 | 1 | 1 | **叶子页表项** | 读写执行页面 |

## 特殊情况说明

### 大页支持

RV39支持三种页面大小：

1. **4KB页面**: 在L0级页表中的叶子页表项
2. **2MB大页**: 在L1级页表中的叶子页表项（PPN[0]应为0）
3. **1GB巨页**: 在L2级页表中的叶子页表项（PPN[1:0]应为0）

### 访问权限检查

**用户模式访问检查:**
- 需要U=1才能在用户模式下访问
- 特权模式默认可以访问所有页面（除非设置了特殊保护）

**写权限特殊规则:**
- 如果R=0且W=1，这是保留组合，可能导致页面错误

### PBMT字段（Svpbmt扩展）

当支持Svpbmt扩展时：

| PBMT值 | 内存类型 | 描述 |
|--------|----------|------|
| 00 | PMA | 使用物理内存属性 |
| 01 | NC | 不可缓存，强序 |
| 10 | IO | 不可缓存，弱序（I/O访问） |
| 11 | 保留 | 未定义 |

## 页表遍历示例

**地址转换过程:**
1. 从satp寄存器获取根页表物理地址
2. 使用VA[38:30]作为L2页表索引
3. 检查页表项V位和RWX位
4. 如果是指针页表项，继续下一级
5. 如果是叶子页表项，完成地址转换

**C语言结构体表示:**
```c
typedef struct {
    uint64_t v    : 1;   // [0] Valid
    uint64_t r    : 1;   // [1] Read
    uint64_t w    : 1;   // [2] Write
    uint64_t x    : 1;   // [3] Execute
    uint64_t u    : 1;   // [4] User
    uint64_t g    : 1;   // [5] Global
    uint64_t a    : 1;   // [6] Accessed
    uint64_t d    : 1;   // [7] Dirty
    uint64_t rsw  : 2;   // [9:8] Reserved for software
    uint64_t ppn0 : 9;   // [18:10] PPN[0]
    uint64_t ppn1 : 9;   // [27:19] PPN[1]
    uint64_t ppn2 : 26;  // [53:28] PPN[2]
    uint64_t pbmt : 9;   // [62:54] PBMT
    uint64_t n    : 1;   // [63] NAPOT
} rv39_pte_t;
```

## 常见操作宏定义

```c
#define PTE_V     (1UL << 0)   // Valid
#define PTE_R     (1UL << 1)   // Read
#define PTE_W     (1UL << 2)   // Write
#define PTE_X     (1UL << 3)   // Execute
#define PTE_U     (1UL << 4)   // User
#define PTE_G     (1UL << 5)   // Global
#define PTE_A     (1UL << 6)   // Accessed
#define PTE_D     (1UL << 7)   // Dirty

#define PTE_PPN_SHIFT    10
#define PTE_PPN_MASK     ((1UL << 44) - 1)

#define PTE_TABLE(pte)   (((pte) & (PTE_V | PTE_R | PTE_W | PTE_X)) == PTE_V)
#define PTE_LEAF(pte)    (((pte) & (PTE_V | PTE_R | PTE_W | PTE_X)) != PTE_V && ((pte) & PTE_V))
```